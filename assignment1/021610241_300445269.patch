Index: ulib.c
===================================================================
--- ulib.c	(revision 3)
+++ ulib.c	(working copy)
@@ -103,3 +103,116 @@
     *dst++ = *src++;
   return vdst;
 }
+
+// Like strncpy but guaranteed to NUL-terminate.
+char*
+safestrcpy(char *s, const char *t, int n)
+{
+  char *os;
+  
+  os = s;
+  if(n <= 0)
+    return os;
+  while(--n > 0 && (*s++ = *t++) != 0)
+    ;
+  *s = 0;
+  return os;
+}
+
+/*******************************STUDENT*******************************/
+
+/***********************************************
+ * standard library functions re-implemented.
+ * see "man <function>" for details.
+ **********************************************/
+  
+int
+strspn(const char *s1, const char *s2)
+{
+	const char *sc1, *sc2;
+	
+	for (sc1 = s1; *sc1 != '\0'; ++sc1)
+		for (sc2 = s2; ; ++sc2)
+			if (*sc2 == '\0')
+				return sc1 - s1;
+			else if (*sc1 == *sc2)
+				break;
+	return sc1 - s1;
+}
+
+
+int
+strcspn(const char *s1, const char *s2)
+{
+	const char *sc1, *sc2;
+	
+	for (sc1 = s1; *sc1 != '\0'; ++sc1)
+		for (sc2 = s2; *sc2 != '\0'; ++sc2)
+			if (*sc1 == *sc2)
+				return sc1 - s1;
+	return sc1 - s1;
+}
+
+
+char
+*strpbrk(const char *s1, const char *s2)
+{
+	const char *sc1, *sc2;
+	
+	for (sc1 = s1; *sc1 != '\0'; ++sc1)
+		for (sc2 = s2; *sc2 != '\0'; ++sc2)
+			if (*sc1 == *sc2)
+				return (char *) sc1;
+	return 0;
+}
+
+
+char
+*strsep(char **stringp, const char *delim)
+{
+  char *begin, *end;
+
+  begin = *stringp;
+  if(begin == 0)
+    return 0;
+
+  if(delim[0] == '\0' || delim[1] == '\0') {
+    char ch = delim[0];
+
+    if(ch == '\0')
+      end = 0;
+    else {
+      if(*begin == ch)
+        end = begin;
+      else if(*begin == '\0')
+        end = 0;
+      else
+        end = strchr(begin + 1, ch);
+    }
+  }
+  else
+    end = strpbrk(begin, delim);
+
+  if(end) {
+    *end++ = '\0';
+    *stringp = end;
+  }
+  else
+    *stringp = 0;
+
+  return begin;
+}
+
+
+char
+*strcat(char *s1, char *s2)
+{
+	char *s;
+	
+	for (s = s1; *s != '\0'; ++s)
+		;
+	for (; (*s = *s2) != '\0'; ++s, ++s2)
+		;
+	return s1;
+}
+/******************************^STUDENT^******************************/
Index: sysproc.c
===================================================================
--- sysproc.c	(revision 3)
+++ sysproc.c	(working copy)
@@ -88,3 +88,28 @@
   release(&tickslock);
   return xticks;
 }
+
+/********************STUDENT********************/
+int
+sys_wait2(void)
+{
+	int *w, *r;
+	int m, n;
+	
+	
+	n = argptr(0, (void *) &w, sizeof(*w));
+	m = argptr(1, (void *) &r, sizeof(*r));
+	
+	
+	if (m < 0 || n < 0)
+		return -1;
+  return wait2(w, r);
+}
+
+
+int
+sys_nice(void)
+{
+	return nice();
+}
+/******************^^STUDENT^^******************/
Index: param.h
===================================================================
--- param.h	(revision 3)
+++ param.h	(working copy)
@@ -9,4 +9,4 @@
 #define ROOTDEV       1  // device number of file system root disk
 #define MAXARG       32  // max exec arguments
 #define LOGSIZE      10  // max data sectors in on-disk log
-
+#define QUANTA        5  /***STUDENT***/
Index: string.c
===================================================================
--- string.c	(revision 3)
+++ string.c	(working copy)
@@ -102,4 +102,3 @@
     ;
   return n;
 }
-
Index: sanity.c
===================================================================
--- sanity.c	(revision 0)
+++ sanity.c	(revision 0)
@@ -0,0 +1,95 @@
+/***STUDENT***/
+
+/*
+ * Add a program called sanity. This program will fork 30 child processes. Each child process
+ * will have a unique id (from 0 to 29) denoted by cid. All processes whose cid%3=0 will
+ * immediately activate the nice system call once, reducing their priority to medium priority.
+ * All processes whose cid%3=1 will immediately activate the nice system call twice, reducing
+ * their priority to low priority. All processes whose cid%3=2 will remain with high priority.
+ * The code of the child processes will print its cid 500 times and will then call exit.
+
+ * The parent process will wait until its children exit, and then
+ * 1. print the average waiting time, running time and turnaround time of all its children.
+ * 2. print the waiting time, running time and turnaround time of all children in each priority group (i.e the statistics for each group),
+ * 3. print the waiting time, running time and turnaround time of each child process.
+ */
+
+#include "types.h"
+#include "user.h"
+
+#define CHILDS 30
+#define TIMES 500
+
+int
+main(void)
+{
+	int i, j;
+	int wait, run;
+	int highs, meds, lows;
+	uint cid;
+	uint cs[CHILDS]; /* cids */
+	uint ws[CHILDS]; /* waits */
+	uint rs[CHILDS]; /* runs */
+	int ow, or;   /* overall wait and run times */
+	int hw, hr;   /* high    wait and run times */
+	int mw, mr;   /* medium  wait and run times */
+	int lw, lr;   /* low     wait and run times */
+	
+	for (i = 0; i < CHILDS; ++i) {
+		/* child */
+		if (fork() == 0) {
+			cid = getpid();
+			switch (cid % 3) {
+			case 1: nice();   /* fall through */
+			case 0: nice();
+			}
+			for (j = 0; j < TIMES; ++j)
+				printf(1, "%d\n", cid);
+			exit();
+		}
+	}
+	
+	/* parent */
+	highs = meds = lows = 0;
+	ow = or = hw = hr = mw = mr = lw = lr = 0;
+	for (i = 0; i < CHILDS; ++i) {
+		cs[i] = wait2(&wait, &run);
+		ws[i] = wait;
+		rs[i] = run;
+		ow += wait;
+		or += run;
+		switch (cs[i] % 3) {
+		case 0: mw += wait;
+		        mr += run;
+		        ++meds;
+		        break;
+		case 1: lw += wait;
+		        lr += run;
+		        ++lows;
+		        break;
+		case 2: hw += wait;
+		        hr += run;
+		        ++highs;
+		}
+	}
+	
+	printf(1, "overall\t\tavg. run time: %d\n",                 or / CHILDS);
+	printf(1, "overall\t\tavg. wait time: %d\n",                ow / CHILDS);
+	printf(1, "overall\t\tavg. turnaround time: %d\n\n",       (ow + or) / CHILDS);
+	printf(1, "high-priority\tavg. run time: %d\n",             hr / highs);
+	printf(1, "high-priority\tavg. wait time: %d\n",            hw / highs);
+	printf(1, "high-priority\tavg. turnaround time: %d\n\n",   (hw + hr) / highs);
+	printf(1, "medium-priority\tavg. run time: %d\n",           mr / meds);
+	printf(1, "medium-priority\tavg. wait time: %d\n",          mw / meds);
+	printf(1, "medium-priority\tavg. turnaround time: %d\n\n", (mw + mr) / meds);
+	printf(1, "low-priority\tavg. run time: %d\n",              lr / lows);
+	printf(1, "low-priority\tavg. wait time: %d\n",             lw / lows);
+	printf(1, "low-priority\tavg. turnaround time: %d\n\n",    (lw + lr) / lows);
+	
+	for (i = 0; i < CHILDS; ++i) {
+		printf(1, "child %d run time: %d\n",          cs[i], rs[i]);
+		printf(1, "child %d wait time: %d\n",         cs[i], ws[i]);
+		printf(1, "child %d turnaround time: %d\n\n", cs[i], rs[i] + ws[i]);
+	}
+	exit();
+}
Index: sh.c
===================================================================
--- sh.c	(revision 3)
+++ sh.c	(working copy)
@@ -13,6 +13,29 @@
 
 #define MAXARGS 10
 
+/*******************STUDENT******************/
+#define MAXPATHS 1024   /* max number of paths */
+#define MAXPATH 256     /* max length of a path */
+
+char paths[MAXPATHS][MAXPATH];  /* the so-called "PATH" variable */
+char (*pend)[MAXPATH] = paths;  /* pointer to end of paths array */
+
+/* 
+ * Export the paths given by string 's'.
+ */ 
+void
+exportpath(char *s)
+{
+	char *token;
+	char (*pp)[MAXPATH] = paths;
+	
+	while ((token = strsep(&s, ":")) != 0)
+		if (*token != '\0')
+			safestrcpy(*pp++, token, MAXPATH);
+	pend = pp;
+}
+/******************^STUDENT^*****************/
+
 struct cmd {
   int type;
 };
@@ -75,7 +98,20 @@
     ecmd = (struct execcmd*)cmd;
     if(ecmd->argv[0] == 0)
       exit();
+    
     exec(ecmd->argv[0], ecmd->argv);
+    /* if we're here the executable hasn't been found in pwd */
+    
+    /***STUDENT***/
+    char full[MAXPATH];
+    char (*pp)[MAXPATH];
+    /* try any of paths in the environment */
+    for (pp = paths; pp < pend; ++pp) {
+			safestrcpy(full, *pp, MAXPATH);
+			strcat(full, ecmd->argv[0]);
+			exec(full, ecmd->argv);
+		}
+		/**^STUDENT^**/
     printf(2, "exec %s failed\n", ecmd->argv[0]);
     break;
 
@@ -141,37 +177,6 @@
   return 0;
 }
 
-int
-main(void)
-{
-  static char buf[100];
-  int fd;
-  
-  // Assumes three file descriptors open.
-  while((fd = open("console", O_RDWR)) >= 0){
-    if(fd >= 3){
-      close(fd);
-      break;
-    }
-  }
-  
-  // Read and run input commands.
-  while(getcmd(buf, sizeof(buf)) >= 0){
-    if(buf[0] == 'c' && buf[1] == 'd' && buf[2] == ' '){
-      // Clumsy but will have to do for now.
-      // Chdir has no effect on the parent if run in the child.
-      buf[strlen(buf)-1] = 0;  // chop \n
-      if(chdir(buf+3) < 0)
-        printf(2, "cannot cd %s\n", buf+3);
-      continue;
-    }
-    if(fork1() == 0)
-      runcmd(parsecmd(buf));
-    wait();
-  }
-  exit();
-}
-
 void
 panic(char *s)
 {
@@ -492,3 +497,55 @@
   }
   return cmd;
 }
+
+int
+main(void)
+{
+  static char buf[100];
+  int fd;
+  struct cmd *cmd, *ncmd;
+  struct execcmd *ecmd;
+  
+  // Assumes three file descriptors open.
+  while((fd = open("console", O_RDWR)) >= 0){
+    if(fd >= 3){
+      close(fd);
+      break;
+    }
+  }
+  
+  // Read and run input commands.
+  while(getcmd(buf, sizeof(buf)) >= 0)
+  {
+    if (buf[0] == 'c' && buf[1] == 'd' && buf[2] == ' ') {
+      // Clumsy but will have to do for now.
+      // Chdir has no effect on the parent if run in the child.
+      buf[strlen(buf)-1] = 0;  // chop \n
+      if (chdir(buf+3) < 0)
+        printf(2, "cannot cd %s\n", buf+3);
+      continue;
+    }
+    
+    cmd = parsecmd(buf);
+    ncmd = nulterminate(cmd);
+    
+    /***STUDENT***/
+    if (ncmd->type == EXEC) {
+			ecmd = (struct execcmd *) ncmd;
+			if (strcmp(ecmd->argv[0], "export") == 0) {
+				if (strcmp(ecmd->argv[1], "PATH") == 0 && ecmd->argv[2] != 0)
+					exportpath(ecmd->argv[2]);
+				else
+					printf(2, "invalid command.\n");
+				continue;
+			}
+		}
+	/**^STUDENT^**/
+    
+    if(fork1() == 0)
+      runcmd(cmd);
+    wait();
+  }
+  exit();
+}
+
Index: user.h
===================================================================
--- user.h	(revision 3)
+++ user.h	(working copy)
@@ -22,6 +22,8 @@
 char* sbrk(int);
 int sleep(int);
 int uptime(void);
+int wait2(int *wtime, int *rtime); /****STUDENT****/
+int nice(void);                    /****STUDENT****/
 
 // ulib.c
 int stat(char*, struct stat*);
@@ -33,6 +35,14 @@
 char* gets(char*, int max);
 uint strlen(char*);
 void* memset(void*, int, uint);
-void* malloc(uint);
+void* malloc(uint nbytes);
 void free(void*);
 int atoi(const char*);
+char* safestrcpy(char *s, const char *t, int n);
+/***STUDENT***/
+int strcspn(const char *s1, const char *s2);
+char *strpbrk(const char *s1, const char *s2);
+char *strtok(char *s1, const char *s2);
+char *strsep(char **stringp, const char *delim);
+char *strcat(char *s1, char *s2);
+/**^STUDENT^**/
Index: console.c
===================================================================
--- console.c	(revision 3)
+++ console.c	(working copy)
@@ -124,26 +124,74 @@
 //PAGEBREAK: 50
 #define BACKSPACE 0x100
 #define CRTPORT 0x3d4
+#define KEY_LF  0xE4   /**STUDENT**/
+#define KEY_RT 0xE5    /**STUDENT**/
 static ushort *crt = (ushort*)P2V(0xb8000);  // CGA memory
 
+/**************************STUDENT**************************/
 static void
 cgaputc(int c)
 {
   int pos;
+  static int end = 0;      /* end of line */
+  static int begin;        /* begin of line */
+  static int prompt = 1;   /* are we in the same line as $? */
+  static ushort tmp = 0;   /* temp storage for char overriden by cursor */
   
   // Cursor position: col + 80*row.
   outb(CRTPORT, 14);
   pos = inb(CRTPORT+1) << 8;
   outb(CRTPORT, 15);
   pos |= inb(CRTPORT+1);
-
-  if(c == '\n')
-    pos += 80 - pos%80;
-  else if(c == BACKSPACE){
-    if(pos > 0) --pos;
-  } else
+  
+  if (end == 0)
+		end = pos;
+    
+  if (prompt)
+		begin = pos + 2;  /* compensate for $ */
+	prompt = 0;
+  
+  switch (c) {
+	case '\n':
+		pos += 80 - pos%80;
+    prompt = 1;    /* initialize prompt, end and temp */
+    tmp = 0;
+    end = 0;
+    break;
+  case BACKSPACE:
+		if(pos > begin) {
+			int t;
+			for (t = pos + 1; t < end - 1; ++t)   /* shift line left*/
+				crt[t-1] = crt[t];
+			--pos;
+			crt[--end] = 0;
+		}
+		break;
+	case KEY_LF:
+		if (pos > begin) {
+			if (tmp != 0)
+				crt[pos] = tmp;
+			tmp = crt[pos-1];
+			--pos;
+		}
+		break;
+	case KEY_RT:
+		if (pos < end) {
+			if (tmp != 0)
+				crt[pos] = tmp;
+			tmp = crt[pos+1];
+			++pos;
+		}
+		break;
+  default:
+		if (pos < end) {
+			int t;
+			for (t = end; t > pos; --t)   /* shift line right */
+				crt[t] = crt[t-1];
+		}
     crt[pos++] = (c&0xff) | 0x0700;  // black on white
-  
+    ++end;
+	}  
   if((pos/80) >= 24){  // Scroll up.
     memmove(crt, crt+80, sizeof(crt[0])*23*80);
     pos -= 80;
@@ -157,6 +205,8 @@
   crt[pos] = ' ' | 0x0700;
 }
 
+/************************^^STUDENT^^************************/
+
 void
 consputc(int c)
 {
@@ -180,10 +230,12 @@
   uint r;  // Read index
   uint w;  // Write index
   uint e;  // Edit index
+  int o;   // Edit index's offset
 } input;
 
+
 #define C(x)  ((x)-'@')  // Control-x
-
+/**************************STUDENT**************************/
 void
 consoleintr(int (*getc)(void))
 {
@@ -203,18 +255,42 @@
       }
       break;
     case C('H'): case '\x7f':  // Backspace
-      if(input.e != input.w){
+      if (input.e != input.w && input.o + input.e > input.r) {
+				int i;
+				for (i = input.e + input.o; i < input.e; ++i) /* shift buffer left */
+					input.buf[i-1] = input.buf[i];
         input.e--;
         consputc(BACKSPACE);
       }
       break;
+    case KEY_LF:
+			if (input.o + input.e > input.r) {
+				input.o--;
+				consputc(c);
+			}
+			break;
+    case KEY_RT:
+			if (input.o < 0) {
+				input.o++;
+				consputc(c);
+			}
+			break;
     default:
       if(c != 0 && input.e-input.r < INPUT_BUF){
         c = (c == '\r') ? '\n' : c;
-        input.buf[input.e++ % INPUT_BUF] = c;
+        if (c == '\n')
+					input.buf[input.e++ % INPUT_BUF] = c;
+				else {
+					int i;
+					for (i = input.e; i > input.e + input.o; --i)  /* shift buffer right */
+						input.buf[i] = input.buf[i-1];
+					input.buf[(input.e + input.o) % INPUT_BUF] = c;
+					input.e++;
+				}
         consputc(c);
         if(c == '\n' || c == C('D') || input.e == input.r+INPUT_BUF){
           input.w = input.e;
+          input.o = 0;
           wakeup(&input.r);
         }
       }
@@ -223,6 +299,7 @@
   }
   release(&input.lock);
 }
+/************************^^STUDENT^^************************/
 
 int
 consoleread(struct inode *ip, char *dst, int n)
Index: waittest.c
===================================================================
--- waittest.c	(revision 0)
+++ waittest.c	(revision 0)
@@ -0,0 +1,54 @@
+// Test that fork fails gracefully.
+// Tiny executable so that the limit can be filling the proc table.
+
+#include "types.h"
+#include "stat.h"
+#include "user.h"
+
+#define N  1000
+/*
+void
+printf(int fd, char *s, ...)
+{
+  write(fd, s, strlen(s));
+}
+*/
+
+void
+foo()
+{
+  int i;
+  for (i=0;i<100;i++)
+     printf(2, "wait test %d\n",i);
+  sleep(20);
+  for (i=0;i<100;i++)
+     printf(2, "wait test %d\n",i);
+
+}
+
+void
+waittest(void)
+{
+  int wTime;
+  int rTime;
+  int pid;
+  printf(1, "wait test\n");
+
+
+    pid = fork();
+    if(pid == 0)
+    {
+      foo();
+      exit();      
+    }
+    wait2(&wTime,&rTime);
+     printf(1, "hi \n");
+    printf(1, "wTime: %d rTime: %d \n",wTime,rTime);
+
+}
+int
+main(void)
+{
+  waittest();
+  exit();
+}
Index: RRsanity.c
===================================================================
--- RRsanity.c	(revision 0)
+++ RRsanity.c	(revision 0)
@@ -0,0 +1,38 @@
+/***STUDENT***/
+
+
+#include "types.h"
+#include "user.h"
+
+#define TIMES 200
+#define CHILDS 5
+
+int
+main(void)
+{
+  int pid;
+	int i, j;
+	int w, r;
+	int ws[CHILDS];
+	int rs[CHILDS];
+	int ps[CHILDS];
+	
+	for (i = 0; i < CHILDS; ++i) {
+		/* child */
+		if ((pid = fork()) == 0) {
+			for (j = 0; j < TIMES; ++j)
+				printf(1, "child %d prints for the %d time.\n", getpid(), j);
+			exit();
+		}
+	}
+	/* parent */
+	for (i = 0; i < CHILDS; ++i) {
+		r = w = 0;
+		ps[i] = wait2(&w, &r);
+		ws[i] = w;
+		rs[i] = r;
+	}
+	for (i = 0; i < CHILDS; ++i)
+		printf(1, "child %d: wait: %d, run: %d\n", ps[i], ws[i], rs[i]);
+	exit();
+}
Index: Gsanity.c
===================================================================
--- Gsanity.c	(revision 0)
+++ Gsanity.c	(revision 0)
@@ -0,0 +1,30 @@
+/***STUDENT***/
+
+
+/*
+ * This program will print “Father pid is <pid>”, and then sleep
+ * for 10 seconds. Then it will fork once, and both child and parent will print 50 times (each
+ * time in a new line): “process <pid> is printing for the <i> time”, and then exit.
+ */ 
+
+
+#include "types.h"
+#include "user.h"
+
+#define TIMES 50
+
+int
+main(void)
+{
+	int i;
+	uint pid;
+	
+	printf(1, "father pid is %d.\n", getpid());
+	sleep(1000);
+	pid = fork();
+	for (i = 0; i < TIMES; ++i)
+		printf(1, "process %d is printing for the %d time.\n", getpid(), i);
+	if (pid != 0)
+		wait();
+	exit();
+}
Index: exec.c
===================================================================
--- exec.c	(revision 3)
+++ exec.c	(working copy)
@@ -17,6 +17,7 @@
   struct inode *ip;
   struct proghdr ph;
   pde_t *pgdir, *oldpgdir;
+  
 
   if((ip = namei(path)) == 0)
     return -1;
Index: usys.S
===================================================================
--- usys.S	(revision 3)
+++ usys.S	(working copy)
@@ -29,3 +29,5 @@
 SYSCALL(sbrk)
 SYSCALL(sleep)
 SYSCALL(uptime)
+SYSCALL(wait2)   /***STUDENT***/
+SYSCALL(nice)    /***STUDENT***/
Index: Makefile
===================================================================
--- Makefile	(revision 3)
+++ Makefile	(working copy)
@@ -1,3 +1,10 @@
+#####STUDENT
+SCHEDFLAG = RR
+ifeq ($(SCHEDFLAG), 3Q)
+override SCHEDFLAG = THREEQ
+endif
+####^STUDENT^
+
 OBJS = \
 	bio.o\
 	console.o\
@@ -51,7 +58,7 @@
 endif
 
 # If the makefile can't find QEMU, specify its path here
-#QEMU = qemu-system-x86_64
+QEMU = qemu-system-x86_64
 
 # Try to infer the correct QEMU
 ifndef QEMU
@@ -73,7 +80,7 @@
 OBJCOPY = $(TOOLPREFIX)objcopy
 OBJDUMP = $(TOOLPREFIX)objdump
 #CFLAGS = -fno-pic -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -Werror -fno-omit-frame-pointer
-CFLAGS = -fno-pic -static -fno-builtin -fno-strict-aliasing -Wall -MD -ggdb -m32 -Werror -fno-omit-frame-pointer
+CFLAGS = -D $(SCHEDFLAG) -fno-pic -static -fno-builtin -fno-strict-aliasing -Wall -MD -ggdb -m32 -Werror -fno-omit-frame-pointer
 CFLAGS += $(shell $(CC) -fno-stack-protector -E -x c /dev/null >/dev/null 2>&1 && echo -fno-stack-protector)
 ASFLAGS = -m32 -gdwarf-2 -Wa,-divide
 # FreeBSD ld wants ``elf_i386_fbsd''
@@ -148,6 +155,7 @@
 mkfs: mkfs.c fs.h
 	gcc -m32 -Werror -Wall -o mkfs mkfs.c
 
+# STUDENT: _waittest, _RRsanity, _Gsanity, _sanity
 UPROGS=\
 	_cat\
 	_echo\
@@ -164,6 +172,10 @@
 	_usertests\
 	_wc\
 	_zombie\
+	_waittest\
+	_RRsanity\
+	_Gsanity\
+	_sanity
 
 fs.img: mkfs README $(UPROGS)
 	./mkfs fs.img README $(UPROGS)
@@ -229,11 +241,13 @@
 # after running make dist, probably want to
 # rename it to rev0 or rev1 or so on and then
 # check in that version.
+# STUDENT: waittest.c, RRsanity.c, Gsanity.c, sanity.c
 
 EXTRA=\
 	mkfs.c ulib.c user.h cat.c echo.c forktest.c grep.c kill.c\
 	ln.c ls.c mkdir.c rm.c stressfs.c usertests.c wc.c zombie.c\
 	printf.c umalloc.c\
+	waittest.c RRsanity.c Gsanity.c sanity.c\
 	README dot-bochsrc *.pl toc.* runoff runoff1 runoff.list\
 	.gdbinit.tmpl gdbutil\
 
Index: proc.c
===================================================================
--- proc.c	(revision 3)
+++ proc.c	(working copy)
@@ -1,3 +1,5 @@
+/* PROBLEMS WITH FRR */
+
 #include "types.h"
 #include "defs.h"
 #include "param.h"
@@ -7,13 +9,23 @@
 #include "proc.h"
 #include "spinlock.h"
 
+
 struct {
   struct spinlock lock;
   struct proc proc[NPROC];
 } ptable;
 
+/***STUDENT***/
+uint turn = 0;  /* FIFO queue: each process is given a number and each
+                 * time the process with the minimal number is scheduled
+                 */ 
+
+/**^STUDENT^**/
+
 static struct proc *initproc;
 
+extern uint ticks; /**STUDENT**/
+
 int nextpid = 1;
 extern void forkret(void);
 extern void trapret(void);
@@ -54,6 +66,12 @@
     p->state = UNUSED;
     return 0;
   }
+  /***STUDENT***/
+  p->ctime = ticks;
+  p->rtime = 0;
+  p->etime = 0;
+  p->nice = 1;
+  /**^STUDENT^**/
   sp = p->kstack + KSTACKSIZE;
   
   // Leave room for trap frame.
@@ -100,6 +118,7 @@
   p->cwd = namei("/");
 
   p->state = RUNNABLE;
+	p->qtime = turn++;  /**STUDENT**/
 }
 
 // Grow current process's memory by n bytes.
@@ -156,6 +175,7 @@
  
   pid = np->pid;
   np->state = RUNNABLE;
+	np->qtime = turn++;  /**STUDENT**/
   safestrcpy(np->name, proc->name, sizeof(proc->name));
   return pid;
 }
@@ -199,6 +219,7 @@
 
   // Jump into the scheduler, never to return.
   proc->state = ZOMBIE;
+  proc->etime = ticks; /**STUDENT**/
   sched();
   panic("zombie exit");
 }
@@ -230,6 +251,12 @@
         p->parent = 0;
         p->name[0] = 0;
         p->killed = 0;
+        /***STUDENT***/
+        p->ctime = 0;
+        p->rtime = 0;
+        p->etime = 0;
+        p->nice = 1;
+        /**^STUDENT^**/
         release(&ptable.lock);
         return pid;
       }
@@ -263,6 +290,8 @@
 }
 
 
+#if defined DEFAULT || defined RR
+
 //PAGEBREAK: 42
 // Per-CPU process scheduler.
 // Each CPU calls scheduler() after setting itself up.
@@ -300,10 +329,184 @@
       proc = 0;
     }
     release(&ptable.lock);
+  }
+}
 
+#endif /* DEFAULT, RR */
+
+
+
+/*******************************STUDENT*******************************/
+#ifdef FRR
+
+void
+scheduler(void)
+{
+  struct proc *p;
+
+  for(;;) {
+    // Enable interrupts on this processor.
+    sti();
+
+    // Loop over process table looking for process to run.
+    acquire (&ptable.lock);
+    uint min = -1;
+    struct proc *pmin;
+    for (p = ptable.proc; p < &ptable.proc[NPROC]; p++) {
+      if (p->state != RUNNABLE)
+        continue;
+      if (p->qtime < min) {
+	  cprintf(1, "%d\n", p->qtime);
+				min = p->qtime;
+				pmin = p;
+			}
+		}
+
+		// Switch to chosen process.  It is the process's job
+		// to release ptable.lock and then reacquire it
+		// before jumping back to us.
+		proc = pmin;
+		switchuvm(pmin);
+		pmin->state = RUNNING;
+		swtch(&cpu->scheduler, proc->context);
+		switchkvm();
+
+		// Process is done running for now.
+		// It should have changed its p->state before coming back.
+		proc = 0;
+		release(&ptable.lock);
   }
 }
 
+#endif /* FRR */
+
+#if defined GRT || defined THREEQ
+
+#define ANY 0
+#define HIGHEST 1
+#define ratio(x) (ticks == (x)->ctime) ?                        \
+                 1                     :                        \
+                 (((double) (x)->rtime)/(ticks - (x)->ctime))
+
+/* 
+ * Get next process according to GRT policy. if mode is `ANY' it will
+ * search for any process; if mode is `HIGHEST' it will consider only
+ * processes with the highest priority.
+ */ 
+struct proc *
+grt(int mode)
+{
+	struct proc *p;
+	struct proc *pmin = 0;
+	double min = 1.0;
+	double r;
+	
+	for (p = ptable.proc; p < &ptable.proc[NPROC]; p++) {
+		if (p->state != RUNNABLE)
+			continue;
+    if (mode == HIGHEST && p->nice != HIGHEST)
+			continue;
+		if ((r = ratio(p)) <= min) {
+			pmin = p;
+			min = r;
+		}
+	}
+	return pmin;
+}
+#endif /* GRT, THREEQ */
+
+#ifdef GRT
+
+void
+scheduler(void)
+{
+  struct proc *p;
+
+  for(;;) {
+    // Enable interrupts on this processor.
+    sti();
+
+    // Loop over process table looking for process to run.
+    acquire(&ptable.lock);
+    if ((p = grt(ANY)) == 0) {
+			release(&ptable.lock);
+			continue;
+		}
+		// Switch to chosen process.  It is the process's job
+		// to release ptable.lock and then reacquire it
+		// before jumping back to us.
+		proc = p;
+		switchuvm(p);
+		p->state = RUNNING;
+		swtch(&cpu->scheduler, proc->context);
+		switchkvm();
+
+		// Process is done running for now.
+		// It should have changed its p->state before coming back.
+		proc = 0;
+    release(&ptable.lock);
+  }
+}
+#endif /* GRT */
+
+
+#ifdef THREEQ
+
+void
+scheduler(void)
+{
+  struct proc *p;
+	
+  for(;;) {
+    // Enable interrupts on this processor.
+    sti();
+
+    acquire(&ptable.lock);
+    
+    /* try to get a high priority process */
+    if ((p = grt(HIGHEST)) != 0)
+			goto switchp;
+			
+		/* try to get a medium priority process */
+		struct proc *pmin = 0;
+		uint min = -1;
+    for (p = ptable.proc; p < &ptable.proc[NPROC]; p++) {
+      if (p->state != RUNNABLE || p->nice != 2)
+        continue;
+      if (p->qtime < min) {
+				min = p->qtime;
+				pmin = p;
+			}
+		}
+		if (pmin != 0) {
+			p = pmin;
+			goto switchp;
+		}
+		
+		/* no medium and high priority processes, only low. just loop
+		   through process table and find the first runnable. (RR policy) */
+		for (p = ptable.proc; p < &ptable.proc[NPROC]; p++)
+      if (p->state == RUNNABLE && p->nice == 3)
+        break;
+     
+    if (p == &ptable.proc[NPROC]) { /* no process found in entire 3 queues */
+			release(&ptable.lock);
+			continue;
+		}
+switchp:
+		proc = p;
+		switchuvm(p);
+		p->state = RUNNING;
+		swtch(&cpu->scheduler, proc->context);
+		switchkvm();
+		proc = 0;
+		release(&ptable.lock);
+  }
+}
+#endif /* THREEQ */
+
+/*****************************^^STUDENT^^*****************************/
+
 // Enter scheduler.  Must hold only ptable.lock
 // and have changed proc->state.
 void
@@ -330,6 +533,7 @@
 {
   acquire(&ptable.lock);  //DOC: yieldlock
   proc->state = RUNNABLE;
+  proc->qtime = turn++;
   sched();
   release(&ptable.lock);
 }
@@ -473,4 +677,100 @@
   }
 }
 
+/*******************************STUDENT*******************************/
+int
+wait2(int *wtime, int *rtime)
+{
+  struct proc *p;
+  int havekids, pid;
 
+  acquire(&ptable.lock);
+  for(;;) {
+    // Scan through table looking for zombie children.
+    havekids = 0;
+    for (p = ptable.proc; p < &ptable.proc[NPROC]; p++) {
+      if (p->parent != proc)
+        continue;
+      havekids = 1;
+      if(p->state == ZOMBIE) {
+        // Found one.
+        *rtime = p->rtime;
+				*wtime = p->etime - p->ctime - p->rtime;
+        pid = p->pid;
+        kfree(p->kstack);
+        p->kstack = 0;
+        freevm(p->pgdir);
+        p->state = UNUSED;
+        p->pid = 0;
+        p->parent = 0;
+        p->name[0] = 0;
+        p->killed = 0;
+        p->nice = 1;
+				p->ctime = 0;
+        p->rtime = 0;
+        p->etime = 0;
+        release(&ptable.lock);
+        return pid;
+      }
+    }
+
+    // No point waiting if we don't have any children.
+    if (!havekids || proc->killed) {
+      release(&ptable.lock);
+      return -1;
+    }
+
+    // Wait for children to exit.  (See wakeup1 call in proc_exit.)
+    sleep(proc, &ptable.lock);  //DOC: wait-sleep
+  }
+}
+
+int
+nice(void)
+{
+	if (proc->nice >= 3)
+		return -1;
+	proc->nice++;
+	return 0;
+}
+/*****************************^^STUDENT^^*****************************/
+
+
+
+
+
+
+
+
+///* queue plus interface for FIFO Round Robin */
+//#if defined FRR || defined THREEQ
+//#define NQUEUE NPROC+1
+
+//struct proc *queue[NQUEUE];
+//int head = 0;
+//int tail = 0;
+//int size = 0;
+
+//void
+//enq(struct proc *p)
+//{
+	//queue[tail++] = p;
+	//tail %= NQUEUE;
+	//++size;
+//}
+
+//struct proc *
+//deq(void)
+//{
+	//struct proc *p = queue[head++];
+	//head %= NQUEUE;
+	//--size;
+	//return p;
+//}
+
+//struct proc *
+//peek(void)
+//{
+	//return queue[head];
+//}
+//#endif /* FRR, THREEQ */
Index: trap.c
===================================================================
--- trap.c	(revision 3)
+++ trap.c	(working copy)
@@ -51,6 +51,10 @@
     if(cpu->id == 0){
       acquire(&tickslock);
       ticks++;
+      /***STUDENT***/
+      if (proc != 0)
+				proc->rtime++;
+			/**^STUDENT^**/
       wakeup(&ticks);
       release(&tickslock);
     }
@@ -99,11 +103,35 @@
   // until it gets to the regular system call return.)
   if(proc && proc->killed && (tf->cs&3) == DPL_USER)
     exit();
-
+	
+  #if defined DEFAULT || defined GRT
   // Force process to give up CPU on clock tick.
   // If interrupts were on while locks held, would need to check nlock.
-  if(proc && proc->state == RUNNING && tf->trapno == T_IRQ0+IRQ_TIMER)
+  if (proc
+  &&  proc->state == RUNNING
+  &&  tf->trapno == T_IRQ0+IRQ_TIMER)
     yield();
+  #endif /* DEFAULT, GRT */
+  
+	/***STUDENT***/
+	
+  #if defined RR || defined FRR
+  if (proc
+  &&  proc->state == RUNNING
+  &&  tf->trapno == T_IRQ0+IRQ_TIMER)
+		if (proc->rtime % QUANTA == 0)
+			yield();
+	#endif /* RR, FRR */
+	
+	#ifdef THREEQ
+  if (proc
+  &&  proc->state == RUNNING
+  &&  tf->trapno == T_IRQ0+IRQ_TIMER)
+		if (proc->nice == 1 || proc->rtime % QUANTA == 0)
+			yield();
+	#endif /* THREEQ */
+	
+	/**^STUDENT^**/
 
   // Check if the process has been killed since we yielded
   if(proc && proc->killed && (tf->cs&3) == DPL_USER)
Index: proc.h
===================================================================
--- proc.h	(revision 3)
+++ proc.h	(working copy)
@@ -53,6 +53,8 @@
 
 typedef void (*sighandler_t)(void);
 
+extern uint ticks; /**STUDENT**/
+
 // Per-process state
 struct proc {
   uint sz;                     // Size of process memory (bytes)
@@ -68,6 +70,13 @@
   struct file *ofile[NOFILE];  // Open files
   struct inode *cwd;           // Current directory
   char name[16];               // Process name (debugging)
+  /****STUDENT*****/
+  uint ctime;									 // Creation time
+  uint rtime;									 // Running time
+  uint etime;									 // Ending time
+  uint qtime;                  // Time entered the queue
+  uint nice;                   // Priority
+  /***^STUDENT^****/
 };
 
 // Process memory is laid out contiguously, low addresses first:
Index: syscall.c
===================================================================
--- syscall.c	(revision 3)
+++ syscall.c	(working copy)
@@ -98,6 +98,8 @@
 extern int sys_wait(void);
 extern int sys_write(void);
 extern int sys_uptime(void);
+extern int sys_wait2(void);   /***STUDENT***/
+extern int sys_nice(void);    /***STUDENT***/
 
 static int (*syscalls[])(void) = {
 [SYS_fork]    sys_fork,
@@ -121,6 +123,8 @@
 [SYS_link]    sys_link,
 [SYS_mkdir]   sys_mkdir,
 [SYS_close]   sys_close,
+[SYS_wait2]   sys_wait2,   /***STUDENT***/
+[SYS_nice]    sys_nice,    /***STUDENT***/
 };
 
 void
Index: syscall.h
===================================================================
--- syscall.h	(revision 3)
+++ syscall.h	(working copy)
@@ -21,3 +21,5 @@
 #define SYS_link   19
 #define SYS_mkdir  20
 #define SYS_close  21
+#define SYS_wait2  22  /***STUDENT***/
+#define SYS_nice   23  /***STUDENT***/
Index: defs.h
===================================================================
--- defs.h	(revision 3)
+++ defs.h	(working copy)
@@ -116,7 +116,10 @@
 int             wait(void);
 void            wakeup(void*);
 void            yield(void);
+int             wait2(int *wtime, int *rtime);
+int             nice(void);
 
+
 // swtch.S
 void            swtch(struct context**, struct context*);
 
